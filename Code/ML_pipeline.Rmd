---
title: "ML_Trial"
author: "Andrea,Gloria,Lorenzo,Thomas"
date: "`r Sys.Date()`"
output: html_document
---
# Preparatory steps
## Loading packages
Store package names in a vectors for ease of access and to load them easily 
```{r, message=FALSE, warning=FALSE}
knitr::opts_knit$set(root.dir = "D:/VarieTHOM/University/QCB/3_SEMESTRE/Data Mining/Laboratory (Blanzieri)/0_PROJECT/Datasets_finals")
PACKAGES <- c(
  "randomForest",
  "caret", # To create color blind friendly and aesthetic palette
  "ggplot2",        # To plot and save images
  "corrplot",
  "tidyverse",      # To make data handling easier
  "factoextra",     # To get better plots (ggplot wrapper)
  "FactoMineR",
  "glue",           # For generating dynamic file names
  "plotly",
   "dplyr",           # To manage data frames more efficiently
  "kernlab",
  "readr",
  "e1071"
)
#install.packages("glue")
#BiocManager::install("gridExtra")
invisible(lapply(PACKAGES, library, character.only = TRUE))

set.seed(1234)
```

## Managing the data to use

```{r,warning=FALSE}
# Load the data
setwd("D:/VarieTHOM/University/QCB/3_SEMESTRE/Data Mining/Laboratory (Blanzieri)/0_PROJECT/Datasets_finals")
ML_data <- data.frame(read_csv("ML_data.csv",col_names = TRUE))

# set rownames
ML_data <- subset(ML_data, select = -((ncol(ML_data) - 4):ncol(ML_data)))
row.names(ML_data) <- ML_data$...1

# eliminate the columns that are not need
my_data <- subset(ML_data, select = -...1)
#my_data$risk...127 <- NULL


# subset data frame by condition
df_Tumor <- subset(my_data, C_T...125 == "Tumor")


```

## NUMBER COATING

```{r First dumb try }
#str(my_data)

# Getting ready to do predictions

# Number coating the values
## Specify the columns to be label encoded
columns_to_encode <- c("type...126", "C_T...125", "Cell_type...128")
columns_to_encode2 <- c("type...126", "C_T...125")

# Create a new data frame without rows where 'column_name' has value "a"
my_data_train <- subset(my_data, Cell_type...128 != "Unkown")
# Create a new data frame without rows where 'column_name' has value "a"
my_data_predict <- subset(my_data, Cell_type...128 == "Unkown")
my_data_predict$Cell_type...128 <- NULL


my_data_train <- my_data_train %>% mutate_at(columns_to_encode, as.factor)
my_data_predict <- my_data_predict %>% mutate_at(columns_to_encode2, as.factor)
levels(my_data_train$Cell_type...128)




my_data_encoded <- my_data %>% mutate_at(columns_to_encode, as.factor)
my_data_encoded_pure <- my_data_encoded

# create a dicionary like structure to store the labels
## The order corresponds to the number
my_levels <- list(
  type...126 = levels(my_data_encoded$type...126),
  C_T...125 = levels(my_data_encoded$C_T...125),
  Cell_type...128 = levels(my_data_encoded$Cell_type...128)
)

my_levels

#my_data_encoded <- my_data_encoded %>% mutate_at(columns_to_encode, as.numeric)

```

```{r}
model_tuned <- tuneRF(
               x=my_data_train, #define predictor variables
               y=my_data_train$Cell_type...128, #define response variable
               ntreeTry=800,
               mtryStart=4, 
               stepFactor=1.5,
               improve=0.01,
               trace=FALSE, #don't show real-time progress
               plot = TRUE,
               importance = TRUE
               )
```

```{r}
# fit the random forest model
model <- randomForest(Cell_type...128 ~ ., 
                      data = my_data_train,
                      ntree = 500,
                      importance = TRUE,
                      mtry = 6
)

# make predictions on my_data_predict
pred <- predict(model, newdata = my_data_encoded)


# view predictions
predictions <- data.frame(pred)

my_data_encoded$predicted <- predictions$pred

my_data_encoded


```

# First basic plots

```{r}

# Assuming 'model' is your random forest model

## Display fitted model
print(model)  # Using print for a more informative display

# Find RMSE of the best model
# sqrt(model$mse[best_trees])  # Uncomment if you need to print the RMSE

# Plot the test MSE by the number of trees
plot(model, main = "Test MSE by Number of Trees", lwd = 2, type = "l", pch = 16)

# Produce a variable importance plot
varImpPlot(model, main = "Variable Importance Plot", col = "darkgreen")

```


## More important plots

```{r}

#Partial dependence plots illustrate the relationship between a specific feature and the predicted outcome while holding other features constant. #They are useful for understanding the effect of individual features on the model predictions.
partialPlot(model, my_data_train, PC3, col = "darkgreen")


```

## Multiclass SVM

```{r}

#my_data_encoded <- my_data_encoded %>% mutate_at(columns_to_encode, as.numeric)

# Assuming the target variable is in the last column
target_col <- ncol(my_data_train)

# Create a multi-class SVM model
svm_model <- svm(my_data_train[, -target_col], 
                 my_data_train[, target_col],
                 type = "C-classification", # for multi-class classification
                 kernel = "radial") # you can choose a different kernel if needed

# Assuming the target column is missing in my_data_predict
# Remove the last column (the one to be predicted) from my_data_predict
my_data_predict_without_target <- my_data_predict[, -target_col]

# Make predictions using the trained model
predictions <- predict(svm_model, my_data_predict_without_target)

```


